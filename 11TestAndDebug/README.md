<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第十一章：多线程应用的测试和排错](#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E7%9A%84%E6%B5%8B%E8%AF%95%E5%92%8C%E6%8E%92%E9%94%99)
  - [并发相关错误类型](#%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B)
  - [定位并发相关错误的方法](#%E5%AE%9A%E4%BD%8D%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF%E7%9A%84%E6%96%B9%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 第十一章：多线程应用的测试和排错

这章介绍能够降低测试和排错难度的技法，而非具体的并发代码测试方法。

## 并发相关错误类型

并发错误通常都与两大类问题有关：
- 多余的阻塞：
    - 死锁：线程间相互等待，全部阻塞，无法解除阻塞。
    - 活锁：线程间互相等待，不过不是阻塞，而是循环检测（比如自旋锁），导致CPU占用高居不下，但是应用程序停滞不前。
    - IO阻塞及其他外部阻塞：等待外部输入，等待的输入一直没有到达。若一个线程正在等待另一个线程结束，那么后者不应该因外部输入而阻塞。
- 条件竞争：经常造成的问题如下：
    - 数据竞争：对共享内存区域访问未采取同步措施，导致未定义行为。
    - 受到破坏的不变量：表现为空悬指针、随机内存数据损坏等未定义行为。
    - 生存期问题：本质上也是一种不变量破坏，线程生存期超过了所访问数据的生存期。
- 调试措施：
    - 发生死锁时，可以在所属进程附着调试工具，确定是哪些对象同步出现了问题。
    - 而不变量破坏则可能很长时间后才暴露出来，比较难以调试。

## 定位并发相关错误的方法

代码审查定位潜在错误：
- 最好让别人来审查，自己审查总是会沿着自己的思路不容易发现错误。如果没有其他人，也可以过一段时间不太熟悉了之后再来仔细思考一下，可以从不同的角度观察。
- 多线程代码中的审查要点：
    - 并发访问是要保护哪些数据？
    - 如果确保数据受到保护？
    - 如果当前线程正在访问受保护数据，那么其他线程可能正在干什么？
    - 当前线程持有哪些互斥？
    - 其他线程可能持有哪些互斥？
    - 当前线程和其他线程上的操作需要服从什么顺序？这种次序限制如何实施？
    - 当前线程读取的数据是否仍旧合法、有效？该数据是否可能被其他线程改动过？
    - 假定其他线程有可能并发改动数据，那么该改动的发生条件和影响是什么？如何保证改动不会发生？

通过测试定位并发相关错误：
- 单线程的错误基本是确定的，复现也会容易很多。
- 多线程程序中各个线程运行顺序不确定，错误可能难以复现，所以需要仔细设计测试方案，并做好必要的日志记录。
- 如果代码能够切换为单线程运行，那么可以在单线程下运行，测试错误是否依旧存在，已确定是并发代码的问题还是非并发相关代码的问题。

多线程测试技术：
- 压力测试：让代码承受压力运行，看它是否崩溃。
- 组合模拟测试：通过组合方式尽量模拟真实的运行环境。
- 特殊的程序库检测错误：凭借程序库中的同步原语检测各种错误。

测试多线程代码的性能：
- 进行性能测试，确定多线程对于程序的提升。
- 确定程序的瓶颈逻辑。
- 在尽可能多的硬件配置上测试，以测试程序的可伸缩性。（至少在单核和多核上分别测试）。
