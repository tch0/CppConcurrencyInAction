<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第八章：设计并发代码](#%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81)
  - [在线程间切分任务的方法](#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%88%87%E5%88%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95)
  - [影响并发代码性能的因素](#%E5%BD%B1%E5%93%8D%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0)
  - [设计数据结构以提升多线程程序的性能](#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E6%8F%90%E5%8D%87%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD)
  - [设计并发代码时需要额外考虑的因素](#%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81%E6%97%B6%E9%9C%80%E8%A6%81%E9%A2%9D%E5%A4%96%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0)
  - [并发代码的设计实践](#%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 第八章：设计并发代码

## 在线程间切分任务的方法

切分任务的方法：
- 先在线程间切分数据，再开始处理：通常的切分手段是将均分给n个线程，各个线程处理过程中不会通信，每个线程处理完成后再规约结果（如果需要），规约结果的过程可能也可以并行。
- 递归切分数据：最常见的是二分，将数据分成两份，然后在递归调用，切分到某个尺度或者线程到达一定数量后全部交给一个线程处理。最终这个过程在比较简单的情况下可以交给`std::async`决定。
    - 并行链表快排例子：见[P261.ParallelQuickSort.cpp](P261.ParallelQuickSort.cpp)。
    - 这个例子其实是一个特化的线程池，使用`std::thread::hardware_concurrency() - 1`作为线程池的最大线程数量。
- 按照工作类别切分任务：上面的划分都基于一项假设——全部线程均对每段数据执行相同操作，而另一种方法是按照任务性质划分，方便代码解耦与分离关注点，各个线程各司其职，提供可维护性与可扩展性。
    - 依据类别划分任务以分离关注点：比如切分前台处理用户输入与后台处理数据的线程，在不打扰后台数据处理的情况下，最快对用户输入做出响应。
    - 上面的想法固然很好，但是通常前台后台线程会有数据共享，前台界面需要响应后台数据的更新，后台数据处理也可以被前台界面进程发出消息终止。无论何种情况，若线程受到操作请求，它都不关心发出的来源，而只在乎操作应当由自己执行。这种消息机制如何设计是重点。
    - 防范两大风险：
        - 避免分离出错误的关注点，其表现是线程间**共享了非常多的数据**，或**多个线程经常互相等待**，导致线程间发生过量通信。多线程的开销相比收益得不偿失。
        - 解决：如果多个线程经由同一因素通信过于频繁，应该考虑从多个线程中提取出相关功能，整合成一个线程，由其全权负责。又或者两个线程大量通信，但和其他线程通信又非常少，那么应该考虑将他们整合成一个线程。
        - 总体思想就是线程间应该高内聚低耦合。
    - 线程间按照流程划分任务：如果任务处理的是独立的数据项，但是他们的操作流程相同，那么便能才去流水线（pipeline）模式，极尽可能利用系统中可调配的并发资源。
        - 将任务按照步骤划分，每个步骤一个线程，处理完成后即将数据交由下一个步骤的线程处理，当前线程接着处理接下来的数据。
        - 按照步骤切分则可以固定线程数量，而不需要考虑如何动态切分数据、配置线程池之类的问题。

## 影响并发代码性能的因素

在利用多处理器系统时，需要了解哪些因素会影响其性能：
- 即便是只为了分离关注点而使用多线程，也需要令其不至于对性能造成负面影响。

处理器的数量：
- 多线程应用程序的性能受处理器数量和架构影响，即是首要因素也是关键因素。
- 但是开发环境和运行环境可能完全不同，在不同环境下，并发程序的行为和性能特征有着巨大差异。所以必须考虑哪些因素将造成影响，并尽量针对他们进行测试。
- 为了规避核心数量的影响，可以利用`std::thread::hardware_concurrency`来动态调整线程数量。但注意仅应在一个线程中调用这个函数，多个线程中调用可能会引发线程过饱和。如果要多个线程中调用，英爱显式共享已经创建的线程数量这种信息。或者采用`std::async`或者线程池。
- 另外应用程序还会受到和它同时运行的应用程序的影响。而在线程线程数目时如何参考同时运行的应用程序影响、或者依据操作系统会规避一个程序同时运行在所有核心上的机制（如果有这个机制）则需要查看操作系统文档。

数据竞争和缓存乒乓（cache ping-pong）：
- 如果两个线程在两个处理器上并行，并且共享同一份数据，这不会有问题，两个处理器的缓存中都会有改数据。但是当一个线程修改了数据，可能会导致另一个线程需要等待很长时间等到修改的数据重新加载到缓存后才开始执行。
- 如果一个变量被运行在两个处理器上的两个线程频繁修改，那么双方的缓存都需要频繁重新加载，这种情况称为**缓存乒乓**，会严重影响应用程序性能。
- 比如下面这个函数在多个线程上执行时：
```C++
std::atomic<int> counter(0);
void processingLoop()
{
    while (counter.fetch_add(1, std::memory_order_relaxed) < 1000000>)
    {
        do_something();
    }
}
```
- 防范缓存乒乓的方法与改善并发程度的通用指引紧密关联：尽量降低两个线程争夺同一内存范围的可能性。

不经意共享：
- 通常，处理器的缓存单元并非独立的小片内存范围，而是连续的大块内存，称为缓存块（或者缓存行），通常是32字节或者64字节。
- 若多个小型数据在内存位置相邻，那么也可能被载入统一缓存块，从而导致多个处理器运行多个线程时虽然没有数据竞争但是缓存中存在共享的数据。从而导致缓存乒乓。
- 解决方法是编排数据布局，使得相同线程访问的数据在内存中彼此靠近，而不同线程访问的数据在内存中彼此远离。
- C++17提供了`<new>`中`std::hardware_destructive_interference_size`提供了一个字节数为单位的限度，如果两个数据相邻区域比它小，那么就可能造成数据共享。

数据的紧凑程度：
- 同理，同一线程中如果数据太过分散，也可能影响单个线程访问数据的性能。
- C++17同时还提供了鼓励共享的最大连续内存大小：`std::hardware_constructive_interference_size`。
- 在线程过饱和时，线程切换加剧会导致缓存未命中频发。

过度任务切换和线程过饱和：
- 线程过多，会导致操作系统频繁切换以公平分配时间片。
- 如果线程过多，可以适当限制工作线程数量。

## 设计数据结构以提升多线程程序的性能

针对复杂数据的划分：
- 通过上面我们知道，内存布局不止会影响多线程程序性能，同时也会影响多线程。

针对复杂操作的数据划分：
- 总之核心逻辑就是提高空间局部性。
- 比如大矩阵相乘，按行存储，按行读取空间局部性就强，按列存储空间局部性就弱。可以设计不同内存布局的矩阵，将按行存储的矩阵乘以按列存储的矩阵，就能同时保证两个举证的空间局部性。

其他数据结构的访问模式：
- 使用动态分配的数据，从而避免不经意的多线程间数据共享。
- 或者在可能会共享的数据见加入巨大的填充块（block of padding）。

## 设计并发代码时需要额外考虑的因素

异常安全：
- 并发代码中应该最大限度的考虑异常安全，略。
- 避免异常抛出时形成死锁等情况。

可伸缩性：
- 一个优秀的多线程程序应该可伸缩的在不同处理器上表现出不同性能，核心增加，性能也应该对应的提升。
- 另外需要考虑阿姆达尔定理，并行程序中性能瓶颈是串行部分，如果串行的部分有1/3，那么无论开多少线程都打不到单线程的三倍性能。

利用多线程掩藏等待行为：
- 某些时候需要进行IO或者等待某些事件到来，使用多线程提供前台程序的正常处理和响应，然后将这些等待放到后台线程（异步IO），可以合理地掩藏等待行为，而不至于造成程序卡顿和阻塞。

并发改进响应能力：
- 比如GUI程序中，GUI线程一定要快速响应专注于GUI，至于任务则派发到后台线程中处理。以提高用户体验。

## 并发代码的设计实践

`std::for_each/std::find/std::partial_sum`的并发实现：略。