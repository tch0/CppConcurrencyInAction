<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第六章：基于锁的数据结构](#%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
  - [并发结构的内涵](#%E5%B9%B6%E5%8F%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E6%B6%B5)
  - [基于锁的并发数据结构](#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
  - [设计更复杂的基于锁的并发数据结构](#%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 第六章：基于锁的数据结构

依靠编程全面解决问题的过程中，数据结构的选择是其中最关键的因素，并行编程也不例外。
- 要让多线程并发访问一个数据结构，要么程序完全不可变，所有数据都可更改，要么设计精良，保证多个线程正确同步。
- 设计并发数据结构一种方式是使用独立互斥和外部锁。
- 另一种则是为并发访问自行设计数据结构。

## 并发结构的内涵

线程安全的数据结构：
- 满足以下条件的数据结构可以认为是线程安全的：
    - 多线程执行的操作无论异同，每个线程所见的数据结构都是自洽的。
    - 数据不会丢失或者损坏，所有不变量都始终成立，恶性条件竞争不会出现。
- 我们可能会遇到以下情况：
    - 多个线程在某数据结构上并发执行某一操作，但另一个线程却要求排他方式访问。
    - 同一数据结构上，多个线程执行不同操作安全，但执行同一操作却不安全。
- 使用互斥保护数据结构的方式是明令阻止并行化，称这种行为为串行话（serialization）：每个线程轮流访问受互斥保护的数据，它们只能串行依次访问，而非并发访问。
- 保护范围越小，需要串行化的操作就越少，并发程度就能越高。

设计指引：
- 保证不变量不被破坏。
- 避免固有的条件竞争，提供完整而非零散的操作。
- 注意异常安全，当抛出异常时，确保不变量不被破坏。

## 基于锁的并发数据结构

核心奥义：先确保锁定合适的互斥，再访问数据，尽可能缩短持锁时间。
- 使用锁实现线程安全的栈：见[03ShareData/P49.ThreadSafeStack.cpp](../03ShareData/P49.ThreadSafeStack.cpp)。
- 使用锁和条件变量实现线程安全的队列：见[04Synchronization/P78.ThreadSafeQueue.cpp](../04Synchronization/P78.ThreadSafeQueue.cpp)。
- 将元素定义为智能指针避免拷贝和移动可能抛出异常带来的影响：见[P185.ThreadSafeQueue.cpp](P185.ThreadSafeQueue.cpp)。

采用细粒度的锁和条件变量实现线程安全的队列：
- 前面的设计中仅保护一项数据，所以只用到一个互斥。
- 为了采取细粒度的锁操作，需要深入队列实现，分析组成，为不同的数据单独使用互斥，就不能使用标准库实现了。
- 通常使用单向链表来充当队列的数据结构。
- 实现见：[P187.FineGrainedThreadSafeQueue.cpp](P187.FineGrainedThreadSafeQueue.cpp)。
- 链表中只有两个指针`head tail`，所以只需要两个互斥锁，获取和修改`tail`的时候对`tailMutex`加锁，抛出头结点时`head`加锁即可。
- `waitAndPop`实现则需要添加条件变量来通知和等待。

## 设计更复杂的基于锁的并发数据结构

对于栈和队列这种比较简单的数据结构，实现并发版本也会比较简单。这里看一看更复杂的数据结构——**查找表**（也就是字典）。
- C++标准库中这一功能由关联容器提供，即`std::map/std::multimap/std::unordered_map/std::unordered_multimap`。
- 对于并发实现来说，标准库容器的接口并不合适，需要做裁剪和修改。
- 其中最大的问题就是迭代器，迭代器将访问和修改权暴露了出去，而不是用接口封装，这使得要保证并发环境下迭代器的使用安全变得异常困难，故最好的选择就是剔除迭代器。
    - 类似地，索引运算符也不会提供。
- 基本操作：
    - 增加配对的键值对（增）。
    - 根据给定的键改变其值（改）。
    - 移除每个键和其关联的值（删）。
    - 根据给定的键获取其关联的值（查）。
- 另外一些容器自身的操作也很有用，比如判空、以快照方式复制所有键和或者所有键值对。
- 一些实现策略：
    - 最有可能诱发竞争的情况是键值对的插入和修改。所以最好将插入和修改操作合并成一个操作。
    - 另外有一点很重要，如果键不存在，是告知键不存在，还是返回默认值。
        - 可以准许用户设定默认值，如果不存在，则返回这个值。
        - 或者返回一个`std::pair<mapped_type, bool>`，用第二个成员表示是否获取到值。
        - 也可以返回智能指针，如果为空指针则表明键不存在。
    - 可以使用`std::shared_mutex`支持读写时加不同层次的锁。
- 考虑实现方式：
    - 一般来说查找表有三种实现方式：平衡二叉树、有序数组、哈希表。
    - 使用平衡二叉树的实现在遍历和修改时都需要从根节点出发，就需要从根节点开始锁定，不利于提供并发性。
    - 有序数组则更差，它无法预知锁需查找的目标的位置，只有对整个列表使用单一的锁。
    - 所以线程安全的查找表最佳实现方式是使用哈希表。
- 一般来说实现都是使用拉链法，固定大小的数组作为一个个桶，不同的桶间就可以并发访问。
- 如果采用读写锁，那么每一个桶都可以由多个读线程一个写线程并发访问。
- 类似于标准库实现，通过模板参数传递哈希函数，默认为`std::hash<>`可以最大化灵活程度。
- 某些时候我们需要获取一个查找表的快照，比如保存为`std::map`，有了这样的操作后查找表功能便更加强大。此时就需要锁住所有桶，按照相同顺序锁住就不用担心死锁问题。
- 实现见：[P201.ThreadSafeLookupTable.cpp](P201.ThreadSafeLookupTable.cpp)。
- 其中没有实现自动再哈希，需要预先得知可能存储的元素数量以方便构造时给定。如果要实现rehash也应该锁住所有桶，完成后再解锁。

实现线程安全的链表：
- 上面的查找表实现中，每个桶内部是使用的`std::list`，对每个桶加锁时，即是对整个链表上锁，所以桶内部读写是不能并发访问的（其实即便如此并发性能其实已经很好了，桶内读取是可以并发的）。
- 如果使用更细粒度的锁实现线程安全的支持迭代器的链表替代`std::list`，就能进一步释放并发性能，即使在桶内也可以并发读写。
- 线程安全的链表实现见：[P205.ThreadSafeLinkedList.cpp](P205.ThreadSafeLinkedList.cpp)。
- 这里的支持迭代器并非是指将迭代器通过接口暴露出来，前面说过在并发数据结构中非常难以实现，所以更好的方式是提供一个`forEach`接口，传入函数进行迭代以实现和提供迭代器一样的功能。
- 可以使用此实现替代`std::list`实现查找表，略。
